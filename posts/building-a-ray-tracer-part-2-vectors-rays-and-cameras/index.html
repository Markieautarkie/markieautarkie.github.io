<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="en-gb"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Building a Ray Tracer - Part 2: Vectors, Rays and Cameras" /><meta property="og:locale" content="en" /><meta name="description" content="The previous post introduced the ray tracing project Manta Ray, which we put in motion by writing an image to the screen buffer of the renderer. Next, we’re going to take a look at vectors, rays and a simple camera system for the renderer." /><meta property="og:description" content="The previous post introduced the ray tracing project Manta Ray, which we put in motion by writing an image to the screen buffer of the renderer. Next, we’re going to take a look at vectors, rays and a simple camera system for the renderer." /><link rel="canonical" href="https://markieautarkie.github.io/posts/building-a-ray-tracer-part-2-vectors-rays-and-cameras/" /><meta property="og:url" content="https://markieautarkie.github.io/posts/building-a-ray-tracer-part-2-vectors-rays-and-cameras/" /><meta property="og:site_name" content="Mark’s Lil’ Corner" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-11T21:04:07+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Building a Ray Tracer - Part 2: Vectors, Rays and Cameras" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-30T00:13:55+02:00","datePublished":"2022-07-11T21:04:07+02:00","description":"The previous post introduced the ray tracing project Manta Ray, which we put in motion by writing an image to the screen buffer of the renderer. Next, we’re going to take a look at vectors, rays and a simple camera system for the renderer.","headline":"Building a Ray Tracer - Part 2: Vectors, Rays and Cameras","mainEntityOfPage":{"@type":"WebPage","@id":"https://markieautarkie.github.io/posts/building-a-ray-tracer-part-2-vectors-rays-and-cameras/"},"url":"https://markieautarkie.github.io/posts/building-a-ray-tracer-part-2-vectors-rays-and-cameras/"}</script><title>Building a Ray Tracer - Part 2: Vectors, Rays and Cameras | Mark's Lil' Corner</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Mark's Lil' Corner"><meta name="application-name" content="Mark's Lil' Corner"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://secure.gravatar.com/avatar/017ef1bed479b400e103660ad49bab33.png?size=512" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Mark's Lil' Corner</a></div><div class="site-subtitle font-italic">Sometimes I code stuff!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Markieautarkie" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['markieautarkie','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Building a Ray Tracer - Part 2: Vectors, Rays and Cameras</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Building a Ray Tracer - Part 2: Vectors, Rays and Cameras</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1657566247" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 11, 2022 </em> </span> <span> Updated <em class="" data-ts="1659132835" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 30, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/markieautarkie">Mark Berentsen</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1925 words"> <em>10 min</em> read</span></div></div></div><div class="post-content"><p>The <a href="https://markieautarkie.github.io/posts/building-a-ray-tracer-part-1-hello-manta-ray/">previous post</a> introduced the ray tracing project <em>Manta Ray</em>, which we put in motion by writing an image to the screen buffer of the renderer. Next, we’re going to take a look at vectors, rays and a simple camera system for the renderer.</p><h2 id="vectors"><span class="mr-2">Vectors</span><a href="#vectors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>At the heart of ray tracers (or almost any graphical program for that matter) lay vectors. As you might already know, a vector is a quantity that has a <em>magnitude</em> and a <em>direction</em>, commonly represented by a line segment. We’ll be using vectors to denote many types of data within the program such as <strong>directions</strong>, <strong>locations</strong>, <strong>offsets</strong> and even <strong>colors</strong>.</p><p>Luckily, the <a href="https://github.com/jbikker/advgrtmpl8">base template</a> we’re using has already implemented vector constructions and accompanying mathematics for us. Since we work in 3D space, the predefined <code class="language-plaintext highlighter-rouge">float3</code> struct is just what we need; it stores <em>x</em>, <em>y</em> and <em>z</em> coordinate components with floating point precision and it has all the vector functions we’d need for now. Going forward, I will assume that you have a basic understanding of vector related mathematics!</p><blockquote class="prompt-info"><div><p>New to vectors or do you need a refresher? <a href="https://www.youtube.com/watch?v=Ej3ZVxljJfo"><strong>This video</strong></a> is a great recap of everything you’d need to know about vector math!</p></div></blockquote><h3 id="color-simplification"><span class="mr-2">Color simplification</span><a href="#color-simplification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>At the moment we pass the <code class="language-plaintext highlighter-rouge">screen-&gt;Plot</code> function a <code class="language-plaintext highlighter-rouge">uint</code> for a color. Shifting bits around whenever we need to work with colors isn’t very intuitive, so let’s practice what we preach and use <code class="language-plaintext highlighter-rouge">float3</code> to represent colors instead.</p><p>First, we define a <code class="language-plaintext highlighter-rouge">color</code> alias for <code class="language-plaintext highlighter-rouge">float3</code>:</p><div class="language-c++ nolineno highlighter-rouge" file="precomp.h"><div class="code-header"> <span data-label-text="precomp.h"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// type alias for float3, defined below its existing struct implementation</span>
<span class="k">using</span> <span class="n">color</span> <span class="o">=</span> <span class="n">float3</span><span class="p">;</span>
</pre></table></code></div></div><p>Let’s create a utility function that helps us convert a <code class="language-plaintext highlighter-rouge">color</code> back to a <code class="language-plaintext highlighter-rouge">uint</code>:</p><div file="color.h" class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="color.h"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#pragma once
</span>
<span class="kr">inline</span> <span class="n">uint</span> <span class="nf">convert_color</span><span class="p">(</span><span class="k">const</span> <span class="n">color</span><span class="o">&amp;</span> <span class="n">pixel_color</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// convert the calculated values from a [0, 1] range to a [0, 255] RGB range,</span>
    <span class="c1">// then shift the bits to combine the colors in one unsigned integer</span>
    <span class="k">return</span>
        <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">255.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">pixel_color</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span>
        <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">255.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">pixel_color</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span>
        <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">255.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">pixel_color</span><span class="p">.</span><span class="n">z</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now we can reflect these changes in our main source file:</p><div file="mantaray.cpp" class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="mantaray.cpp"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// this method is called once per frame while the application is running</span>
<span class="kt">void</span> <span class="n">mantaray</span><span class="o">::</span><span class="n">Tick</span><span class="p">(</span><span class="kt">float</span> <span class="n">deltaTime</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// clear the previously drawn frame by resetting the screen buffer to black</span>
    <span class="n">screen</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// loop over all the screen buffer pixels as if reading a book: left-&gt;right, top-&gt;bottom</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">SCRHEIGHT</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">SCRWIDTH</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// calculate some values for the red, green and blue components of a pixel</span>
        <span class="n">color</span> <span class="n">pixel_color</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">SCRWIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mf">0.25</span><span class="n">f</span><span class="p">,</span> <span class="kt">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">SCRHEIGHT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        
        <span class="c1">// draw the color to the current screen buffer pixel</span>
        <span class="n">screen</span><span class="o">-&gt;</span><span class="n">Plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">convert_color</span><span class="p">(</span><span class="n">pixel_color</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="ray-tracing-in-a-nutshell"><span class="mr-2">Ray tracing in a nutshell</span><a href="#ray-tracing-in-a-nutshell" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In the previous post I mentioned that ray tracers try to simulate real-life physics. The image below gives an overview of a typical ray tracing <em>scene:</em></p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 416 416'%3E%3C/svg%3E" data-src="https://i.postimg.cc/90j0YS8h/ray-tracing-overview.png" alt="Ray Tracing Overview" width="416" height="416" data-proofer-ignore> <em>A simplified overview of a typical ray tracing scenario.</em></p><p>Here we see a <em>camera</em> (depicted as an eye) shooting rays into the scene through a <em>virtual viewport</em> (the black line). This is the core concept of ray tracing: sending rays through pixels, then computing the color seen along those rays to render an image. We can dissect this process into the following steps:</p><ol><li><strong>Ray calculation</strong>: calculate the rays from the camera to every pixel on the virtual viewport (the red arrows). These rays are also called <em>primary rays</em>.<li><strong>Ray intersection</strong>: calculate the <em>nearest intersection point</em> between each ray and any object in the scene, if it exists. Only the nearest intersection is important; any intersection further along the ray is obstructed by the first one anyway!<li><strong>Ray color</strong>: compute a color for the found intersection points, summing up the contribution of any light sources visible from each point. This is achieved by so-called <em>shadow rays</em> (the yellow dashed lines).</ol><p>For now, let’s solely focus on the first step. To calculate rays spawning from the camera, we’d need to (obviously) put both in the code somehow, which will be our next focus point.</p><blockquote class="prompt-info"><div><p>You might have noticed that ray tracing handles light transport <em>backwards;</em> that is, from camera to light source. This gives the renderer a performance boost as we only care about the rays that’ll actually hit the camera.</p></div></blockquote><h3 id="implementing-rays"><span class="mr-2">Implementing rays</span><a href="#implementing-rays" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>All ray tracers have some implementation in place to compute ray-specific values in order to render an image (I know, total shocker right?). A ray can be defined as an <em>infinite half-line;</em> basically a <strong>line in 3D space with a starting point</strong>. This leads to the following function:</p>\[P(t) = O + t\overrightarrow{D}\]<p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 320'%3E%3C/svg%3E" data-src="https://i.postimg.cc/gkw86BbN/ray-example.png" alt="Ray Example" width="320" height="320" style="max-width: 50%" class="right" data-proofer-ignore> Where $O$ is the <em>ray origin</em> and $\overrightarrow{D}$ the <em>(normalized) direction</em> of the ray. Any 3D point $P$ along the ray can be found by plugging in values for $t$, where $t \geq 0$. In other words, different values for $t$ moves point $P$ along the ray. This will be useful to find the exact intersection points of a ray with objects in a scene.</p><p>Let’s add a ray class to the project which implements this functionality:</p><div file="ray.h" class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="ray.h"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#pragma once
</span>
<span class="k">class</span> <span class="nc">ray</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">float3</span> <span class="n">m_origin</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">m_direction</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="c1">// constructors, ray direction is normalized</span>
    <span class="n">ray</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">ray</span><span class="p">(</span><span class="k">const</span> <span class="n">float3</span><span class="o">&amp;</span> <span class="n">origin</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span><span class="o">&amp;</span> <span class="n">direction</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_origin</span><span class="p">(</span><span class="n">origin</span><span class="p">),</span> <span class="n">m_direction</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">direction</span><span class="p">))</span> <span class="p">{}</span>

    <span class="c1">// getters</span>
    <span class="n">float3</span> <span class="n">origin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_origin</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">float3</span> <span class="n">direction</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_direction</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// gets the position for the given t value</span>
    <span class="n">float3</span> <span class="n">point</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_origin</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">m_direction</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><blockquote class="prompt-warning"><div><p>Normalizing the ray direction isn’t strictly necessary at this stage. However, forgetting to normalize when it <em>does</em> matter can lead to strange bugs. Be wary of this if you choose to omit it for now!</p></div></blockquote><h3 id="implementing-a-camera"><span class="mr-2">Implementing a camera</span><a href="#implementing-a-camera" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Next, the camera. The camera consist of a <em>position</em> and a <em>virtual viewport</em>; the viewport is comparable to a lens in a real camera.</p><p>To start, let’s define an <em>aspect ratio</em> for the screen buffer of the renderer (16:9 is a common standard), which we can use to set the screen resolution as well:</p><div class="language-c++ nolineno highlighter-rouge" file="common.h"><div class="code-header"> <span data-label-text="common.h"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">constexpr</span> <span class="kt">float</span> <span class="n">m_aspect</span> <span class="o">=</span> <span class="mf">16.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">9.0</span><span class="n">f</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">m_scr_width</span> <span class="o">=</span> <span class="mi">640</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">m_scr_height</span> <span class="o">=</span> <span class="n">m_scr_width</span> <span class="o">/</span> <span class="n">m_aspect</span><span class="p">;</span>

<span class="cp">#define ASPECT      m_aspect
#define SCRWIDTH    m_scr_width
#define SCRHEIGHT   m_scr_height
</span></pre></table></code></div></div><p>For the viewport we will use the same aspect ratio to ensure the pixels are perfect squares. We could always change this later to get cool effects such as <a href="https://the-pro-photographer.com/wp-content/uploads/2017/07/Barrel-Distortion.png">barrel- or pincushion distortion</a>… Kinda like changing lenses on a camera!</p><p>The viewport will be two units in height, as will be the distance between the camera origin and the viewport (the <em>focal length</em> of a camera). To keep things simple, let’s put the camera origin at $(0, 0, 0)$. Recall from the previous post that the coordinate system in graphics applications starts in the top-left corner, where <em>x</em> and <em>y</em> are positive when going to the right and down respectively. Hence why I have chosen to do the same for the camera coordinate system, making the program less confusing. To respect the <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right handed coordinate system</a>, the <em>z-axis</em> will be positive going into the screen; or differently phrased, the value of <em>z</em> will be larger when the depth is greater.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3C/svg%3E" data-src="https://i.postimg.cc/SNTkYkpz/camera-and-viewport-geometry.png" alt="Camera and Viewport Geometry" width="512" height="512" data-proofer-ignore> <em>An overview of the camera and viewport geometry.</em></p><p>The last thing we need to set up is a way to position a ray relative to the viewport. By traversing the screen from the top-left corner, we can reach any pixel on the viewport by “walking” a certain distance along the <em>horizontal</em> and <em>vertical</em> axis vectors of the viewport. We denote this distance as $u$ for the horizontal axis, and $v$ for the vertical one. This gives the following formula for any point on the virtual viewport:</p>\[P(u, v) = P_{topleft} + u\overrightarrow{D}_{hor} + v\overrightarrow{D}_{vert}\]<p>Where $u, v \in [0, 1]$. Thus, $u$ and $v$ determine the <em>ratio</em>, where $(u, v = 0)$ is the top-left corner, and $(u, v = 1)$ the bottom-right one (similar to the color rendering in the previous post!).</p><p>Now that we finally have a position on the virtual viewport, we can construct a ray from the camera through this position by subtracting the camera origin:</p>\[\overrightarrow{D}_{ray} = P(u, v) - P_{origin}\]<p>Pfew, time to translate this all to code:</p><div file="camera.h" class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="camera.h"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#pragma once
</span>
<span class="k">class</span> <span class="nc">camera</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">float3</span> <span class="n">m_origin</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">m_horizontal</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">m_vertical</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">m_focal</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">m_upper_left_corner</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">camera</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// initialize the viewport dimensions</span>
        <span class="kt">float</span> <span class="n">viewport_height</span> <span class="o">=</span> <span class="mf">2.0</span><span class="n">f</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">viewport_width</span> <span class="o">=</span> <span class="n">ASPECT</span> <span class="o">*</span> <span class="n">viewport_height</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">focal_length</span> <span class="o">=</span> <span class="mf">2.0</span><span class="n">f</span><span class="p">;</span>

        <span class="c1">// create the viewport by defining the horizontal/vertical/focal vectors </span>
        <span class="c1">// and set the camera origin at (0.0f,0.0f,0.0f)</span>
        <span class="n">m_origin</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
        <span class="n">m_horizontal</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">viewport_width</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
        <span class="n">m_vertical</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="n">viewport_height</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
        <span class="n">m_focal</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="n">focal_length</span><span class="p">);</span>

        <span class="c1">// calculate the position of the upper left corner of the virtual viewplane,</span>
        <span class="c1">// using the created vectors/positions</span>
        <span class="n">m_upper_left_corner</span> <span class="o">=</span> <span class="n">m_origin</span> <span class="o">-</span> <span class="n">m_horizontal</span> <span class="o">/</span> <span class="mf">2.0</span><span class="n">f</span> <span class="o">-</span> <span class="n">m_vertical</span> <span class="o">/</span> <span class="mf">2.0</span><span class="n">f</span> <span class="o">+</span> <span class="n">m_focal</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// fire a new ray from the camera, with u and v defining the ratio to the viewport</span>
    <span class="n">ray</span> <span class="n">fire_ray</span><span class="p">(</span><span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">ray</span><span class="p">(</span><span class="n">m_origin</span><span class="p">,</span> <span class="n">m_upper_left_corner</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">m_horizontal</span> <span class="o">+</span> <span class="n">v</span> <span class="o">*</span> <span class="n">m_vertical</span> <span class="o">-</span> <span class="n">m_origin</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>To test the new camera, I implemented a simple temporary function which returns a color for a ray depending on its <em>y</em> direction called <code class="language-plaintext highlighter-rouge">ray_color</code>. All these changes are reflected in the main source file as follows:</p><div file="mantaray.cpp" class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="mantaray.cpp"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="n">camera</span> <span class="n">cam</span><span class="p">;</span>

<span class="c1">// returns a background gradient depending on the y direction of a primary ray</span>
<span class="n">color</span> <span class="nf">ray_color</span><span class="p">(</span><span class="k">const</span> <span class="n">ray</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// convert a ray's y value from roughly [-0.5, 0.5] space (due to vector normalization) to [0, 1] space</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">direction</span><span class="p">().</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">;</span>

    <span class="c1">// linear interpolation of the background, t = 0 gives blue-ish, t = 1 gives white, blend in-between</span>
    <span class="k">return</span> <span class="n">lerp</span><span class="p">(</span><span class="n">color</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">),</span> <span class="n">color</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">),</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// this method is called once per frame while the application is running</span>
<span class="kt">void</span> <span class="n">mantaray</span><span class="o">::</span><span class="n">Tick</span><span class="p">(</span><span class="kt">float</span> <span class="n">deltaTime</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// clear the previously drawn frame by resetting the screen buffer to black</span>
    <span class="n">screen</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// loop over all the screen buffer pixels as if reading a book: left-&gt;right, top-&gt;bottom</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">SCRHEIGHT</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">SCRWIDTH</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// calculate the u and v value for the current pixel and fire a ray using these values</span>
        <span class="kt">float</span> <span class="n">u</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">SCRWIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">SCRHEIGHT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">color</span> <span class="n">pixel_color</span> <span class="o">=</span> <span class="n">ray_color</span><span class="p">(</span><span class="n">cam</span><span class="p">.</span><span class="n">fire_ray</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

        <span class="c1">// draw the color to the current screen buffer pixel</span>
        <span class="n">screen</span><span class="o">-&gt;</span><span class="n">Plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">convert_color</span><span class="p">(</span><span class="n">pixel_color</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Behold! Our first “ray traced” image:</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3C/svg%3E" data-src="https://i.postimg.cc/SxXYs5Gs/first-raytraced-image.png" alt="First Raytraced Image" width="512" height="512" data-proofer-ignore> <em>Mr. Blue Sky, please tell us why, you had to hide away for so long (so long)!</em></p><p>It’s… Rather dull for the amount of effort. However! We made some major strides coming to this point. The backbone of our renderer is now (mostly) in place. Next time we will implement <a href="#ray-tracing-in-a-nutshell">step 2</a> of the rendering process: <strong>ray intersection!</strong> See ya later. 🐊</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/projects/'>Projects</a>, <a href='/categories/manta-ray/'>Manta Ray</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c++</a> <a href="/tags/ray-tracing/" class="post-tag no-text-decoration" >ray tracing</a> <a href="/tags/vectors/" class="post-tag no-text-decoration" >vectors</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Building+a+Ray+Tracer+-+Part+2%3A+Vectors%2C+Rays+and+Cameras+-+Mark%27s+Lil%27+Corner&url=https%3A%2F%2Fmarkieautarkie.github.io%2Fposts%2Fbuilding-a-ray-tracer-part-2-vectors-rays-and-cameras%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Building+a+Ray+Tracer+-+Part+2%3A+Vectors%2C+Rays+and+Cameras+-+Mark%27s+Lil%27+Corner&u=https%3A%2F%2Fmarkieautarkie.github.io%2Fposts%2Fbuilding-a-ray-tracer-part-2-vectors-rays-and-cameras%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fmarkieautarkie.github.io%2Fposts%2Fbuilding-a-ray-tracer-part-2-vectors-rays-and-cameras%2F&text=Building+a+Ray+Tracer+-+Part+2%3A+Vectors%2C+Rays+and+Cameras+-+Mark%27s+Lil%27+Corner" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/building-a-ray-tracer-part-3-intersection-galore/">Building a Ray Tracer - Part 3: Intersection Galore!</a><li><a href="/posts/building-a-ray-tracer-part-2-vectors-rays-and-cameras/">Building a Ray Tracer - Part 2: Vectors, Rays and Cameras</a><li><a href="/posts/building-a-ray-tracer-part-1-hello-manta-ray/">Building a Ray Tracer - Part 1: Hello Manta Ray!</a><li><a href="/posts/first-post/">First Post!</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/ray-tracing/">ray tracing</a> <a class="post-tag" href="/tags/abstraction/">abstraction</a> <a class="post-tag" href="/tags/intersections/">intersections</a> <a class="post-tag" href="/tags/introduction/">introduction</a> <a class="post-tag" href="/tags/vectors/">vectors</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/building-a-ray-tracer-part-3-intersection-galore/"><div class="card-body"> <em class="small" data-ts="1659132740" data-df="ll" > Jul 30, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Building a Ray Tracer - Part 3: Intersection Galore!</h3><div class="text-muted small"><p> Last time we left off with a (pretty empty) backdrop for the ray tracing scene. With ray functionality and a basic camera implemented, our focus shifts to actually rendering some primitives. And to...</p></div></div></a></div><div class="card"> <a href="/posts/building-a-ray-tracer-part-1-hello-manta-ray/"><div class="card-body"> <em class="small" data-ts="1656757807" data-df="ll" > Jul 2, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Building a Ray Tracer - Part 1: Hello Manta Ray!</h3><div class="text-muted small"><p> Introduction Many a year ago, my brother got a brand new Nintendo 64 for his birthday. I still fondly remember the first time he flicked it on; seeing that floating Mario head pop up on the CRT in ...</p></div></div></a></div><div class="card"> <a href="/posts/building-a-ray-tracer-part-4-powerful-polymorphism/"><div class="card-body"> <em class="small" data-ts="1659180987" data-df="ll" > Jul 30, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Building a Ray Tracer - Part 4: Powerful Polymorphism</h3><div class="text-muted small"><p> This post is going to tie up the loose ends we left dangling around in the previous post. We put quite some effort into abstracting the setup for intersectable primitives, yet we still have to deal...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/building-a-ray-tracer-part-1-hello-manta-ray/" class="btn btn-outline-primary" prompt="Older"><p>Building a Ray Tracer - Part 1: Hello Manta Ray!</p></a> <a href="/posts/building-a-ray-tracer-part-3-intersection-galore/" class="btn btn-outline-primary" prompt="Newer"><p>Building a Ray Tracer - Part 3: Intersection Galore!</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "markieautarkie/markieautarkie.github.io", "data-repo-id": "", "data-category": "", "data-category-id": "", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/markieautarkie">Mark Berentsen</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/ray-tracing/">ray tracing</a> <a class="post-tag" href="/tags/abstraction/">abstraction</a> <a class="post-tag" href="/tags/intersections/">intersections</a> <a class="post-tag" href="/tags/introduction/">introduction</a> <a class="post-tag" href="/tags/vectors/">vectors</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en-gb.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
